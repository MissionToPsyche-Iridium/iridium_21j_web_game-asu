<html>
<title>
Pre-Launch Dashboard
</title>
  <body style="overflow:scroll;padding:0px 0px;margin:0px 0px;">
    <script>
      const nipi = 2 * Math.PI;
      function drawCircle(graphics,x,y,radius){
        graphics.lineWidth=5;
        
        graphics.beginPath();
        graphics.arc(x,y,radius,0,nipi);
        graphics.stroke();
      }
    </script>

    <!-- canvas will always be the default width for hd-->
    <center>
    <canvas id="naka" width="1920" style="padding:0px 0px;margin:0px 0px;" height="1080"></canvas>
    </center>

    <audio id="clickSound" src="click.mp3" preload="auto"></audio>
    <audio id="failSound" src="fail.mp3" preload="auto"></audio>

    <!-- game logic which will take place here:-->
    <script>

      //mouse info
      const m_width=25;
      const m_height=25;
      const m_radius=Math.floor(m_width,m_height)/2;

      // Red button's position and size (added)
      let red_button_x = 957;
      let red_button_y = 250;
      let red_button_radius = 15.8;

      // button info
      //the first button has priority if the mouse hovers over both
      //when selecting the buttons make sure to get the top x,y, the whole mouse circle is within the button and/or flush with the top left corner of it
      //for the bottom x2,y2, the mouse has to be pointing at the bottom right edge
      //index zero is the big red button
      let buttons_x=[953, 983, 946, 1178, 1211, 1557];
      let buttons_y=[249, 583, 583, 619, 618, 258];
      let buttons_x2=[974, 999, 964, 1198, 1232, 1584];
      let buttons_y2=[264, 606, 606, 636, 635, 275];
      let buttons_taisetsu_index=[];
      let button_chigau=[];

      //button handlers
      function mouse_button_ga_koete(mousex,mousey,mouse_rad,index){
        if(button_chigau.includes(index)){
          return false;//exit if button is invalid
        }

        let bx=buttons_x[index];
        let by=buttons_y[index];
        let bx2=buttons_x2[index];
        let by2=buttons_y2[index];

        let mx=mouse_x;
        let my=mouse_y;
        let mx2=mx+mouse_rad;
        let my2=my+mouse_rad;


        //if the far right of the mouse is past the far left of the button
        //if the far left of the mouse is before the far right of the button
        if(mx2 > bx && mx < bx2){
          //same with y
          if(my2 > by && my < by2){
            return true;
          }
        }
        return false;
      }

      function nani_button_ga_koete(mousex,mousey,mouse_rad){
        for(var i=0;i < buttons_x.length;i++){
          if(mouse_button_ga_koete(mousex,mousey,mouse_rad,i)){
            return i;
          }
        }
        return -1;
      }

      // Highlight the button at the given index
      function highlightButton(index) {
       
        let bx = buttons_x[index];
        let by = buttons_y[index];
        let bx2 = buttons_x2[index];
        let by2 = buttons_y2[index];

        gazou.lineWidth=5;
        gazou.strokeStyle = "rgba(255, 255, 102, 0.9)";  // yellow highlight (now all buttons light up at same time)
        gazou.shadowBlur = 20;  // Add a glowing effect
        gazou.shadowColor = "rgba(255, 255, 224, 0.5)"; //default
        gazou.strokeRect(bx-m_radius, by-m_radius, bx2 - bx + m_radius, by2 - by + m_radius);
        gazou.shadowBlur = 0;  // Reset shadow
      }

      // Highlight the button with a green circle at the given index
      function highlightButton_midori(index) {
       
        let bx = buttons_x[index];
        let by = buttons_y[index];
        let bx2 = buttons_x2[index];
        let by2 = buttons_y2[index];

        let x=bx - m_radius;
        let y=by - m_radius;
        let w=bx2 - bx + m_radius;
        let h=by2 - by + m_radius;
        let nx=x + w/2;
        let ny=y + h/2;

        gazou.lineWidth=5;
        gazou.strokeStyle = "rgba(30, 255, 30, 0.9)";  // yellow highlight (now all buttons light up at same time)
        gazou.shadowBlur = 20;  // Add a glowing effect
        gazou.shadowColor = "rgba(255, 255, 224, 0.5)"; //default
        gazou.beginPath();
        gazou.arc(nx,ny,m_radius,0,nipi);

        gazou.stroke();
        gazou.shadowBlur = 0;  // Reset shadow
      }


      let mouse_x=0;
      let mouse_y=0;

      let clicked_index=-1;

      // Game state variables (added)
      let engine_started = false;
      let start_message = false; 
      let arrow_offset = 0; 
      let random_sequence = [];  // Stores the sequence of blinking buttons
      let current_index = 0;  // Tracks the current button being shown
      let user_sequence = [];  // Stores the user's input sequence
      let sequence_playing = false;  // Prevent user input during sequence playback
      let user_turn = false;
      let final_message = 0;
      let highlight_timeout = null;
      let render_animation=false;
      let ticker=true;
      let ticker_prev=true;
      let before_draw_ticks=0;

      let naka = new Image();
      naka.src = "cockpit.png";

      const draw = document.getElementById("naka");
      const gazou = draw.getContext("2d"); 

      // Check if the mouse is inside the circle (added) no need for this
      /* function isMouseOverCircle(mousex, mousey, center_x, center_y, radius) {
        let distance_squared = (mousex - center_x) ** 2 + (mousey - center_y) ** 2;
        return distance_squared <= radius ** 2;
      }*/

      draw.addEventListener("mousedown",function (hairu){
        let x = hairu.clientX;
        let y = hairu.clientY;
        let koete=nani_button_ga_koete(x,y,m_radius);
        if(koete!=-1){
          clicked_index=koete;
          // added the click sound on buttons
          var clickSound = document.getElementById("clickSound");
          clickSound.currentTime = 0;
          clickSound.play();
        }

        // Start the game when the engine button is clicked
        // Allow user to input only during their turn
        let clickedButtonIndex = nani_button_ga_koete(x, y, m_radius);
        if(clickedButtonIndex == 0 && !engine_started){
          startGame();
          engine_started=true;
          start_message=true;
          actually_drawing=false;
          render_animation=true;
          button_chigau.push(0);
        }else if (clickedButtonIndex !== -1 && !render_animation && user_sequence.length < random_sequence.length) {
            console.log(`User clicked button: ${clickedButtonIndex}`);
            checkUserSequence(clickedButtonIndex);  // Check if the user's input is correct
          }

      });

      draw.addEventListener("mousemove",function (hairu){
        mouse_x = hairu.clientX;
        mouse_y = hairu.clientY;
      });

      function checkUserSequence(index){

            user_sequence.push(index);

        console.log(`${user_sequence}`);
        
        if(user_sequence.length >= random_sequence.length){
          let atteru=true;
          for(var i=0; i < random_sequence.length;i++){
            if(user_sequence[i] != random_sequence[i]){
              atteru=false;
              break;
            }
          }

          //user output
          if(atteru){
            final_message=2;
          }else{
            final_message=1;
          }
        }
      }
  
      
      function drawRedButtonOverlay() {
        // Draw a circular overlay for the red button
        gazou.beginPath();
        gazou.arc(red_button_x, red_button_y, red_button_radius, 0, nipi);
        gazou.fillStyle = "rgba(255, 0, 0, 0.5)";  // Red transparent overlay
        gazou.fill();
      }

       // Draw an animated arrow pointing to the red button (added)
      function drawArrow() {
        gazou.beginPath();
        gazou.moveTo(red_button_x - 50, red_button_y - 50 + arrow_offset);  // Arrow tail
        gazou.lineTo(red_button_x, red_button_y - 20 + arrow_offset);  // Arrow tip
        gazou.lineTo(red_button_x + 50, red_button_y - 50 + arrow_offset);  // Other tail
        gazou.lineTo(red_button_x - 50, red_button_y - 50 + arrow_offset);  // Close the arrow shape

        gazou.fillStyle = "rgba(255, 0, 0, 0.8)";  // Red arrow color
        gazou.fill();
        gazou.closePath();

        // Animate the arrow with a bouncing effect
        arrow_offset = (arrow_offset + 0.6) ;  // Bounce between 0 and 20 pixels
        if(arrow_offset > 20){
          arrow_offset=0;
        }
      }

    
      // Reset the game state
      function resetGame() {
        engine_started = false;
        start_message = false; 
        random_sequence = [];
        current_index = 0;
        user_sequence = [];
        sequence_playing = false;
        user_turn = false;
        final_message = 0;
        gazou.drawImage(naka, 0, 0, 1920, 1080);
        render_animation=false;
        actually_drawing=false;
      }

      // Start the game by generating a sequence and showing the buttons
      function startGame() {
        
        console.log(`start`);
        generateRandomSequence();
        current_index = 0;
        user_sequence = [];
        
      }

      // Generate a random sequence of 3 buttons
      function generateRandomSequence() {
        random_sequence = [];

        let hajime=1;
        let kiri=buttons_x.length - hajime;

        let previous=-1;
        let randomIndex;
        for (let i = 1; i < buttons_x.length; i++) {
          randomIndex = hajime + Math.floor(Math.random() * kiri);

          while(randomIndex == previous){
            randomIndex = hajime + Math.floor(Math.random() * kiri);
          }

          random_sequence.push(randomIndex);
          previous=randomIndex;
        }
        console.log(`Generated random sequence: ${random_sequence}`);  // Debugging output
      }

      //ticker:
       setInterval(() => {
            ticker_prev=ticker;
            ticker=!ticker;
          }, 1000);
      function is_tick(){
        if(ticker_prev!=ticker){
          ticker_prev=ticker;
          return true;
        }
        return false;
      }

      let actually_drawing=false;
      let animation_itterator=0;
      
      function kurikaesu(){
        gazou.drawImage(naka,0,0,1920,1080);
        
        // Draw all buttons

        // before engine start (added)
        if (!engine_started) {
          drawArrow();
          gazou.fillStyle = "rgba(0, 0, 0, 0.6)";
          gazou.fillRect(600, 350, 720, 100);

          gazou.fillStyle = "#FFFFFF";
          gazou.font = "50px Arial";
          gazou.textAlign = "center";
          gazou.fillText("Click Engine Button Here to Start", 960, 400);
        }

        //added
        if (start_message) {
          gazou.fillStyle = "rgba(0, 0, 0, 0.6)";  // Background for the message
          gazou.fillRect(600, 400, 720, 100);  // Centered rectangle for the message

          gazou.fillStyle = "#FFFFFF";  // White text
          gazou.font = "50px Arial";
          gazou.textAlign = "center";
          gazou.fillText("Engine started! Get ready to play.", 960, 470);  // Centered text

          // Set a timer to hide the message after 2 seconds (2000 milliseconds)
        }

        // added
        if (engine_started) {
          drawRedButtonOverlay();
        }

        // Show the button sequence if the game has started and it’s not already showing
               //debug coordinates
        gazou.fillStyle="#FFF"
        gazou.font = "15px Arial";
        gazou.fillText(mouse_x + "," + mouse_y,30,30);

        //do not render hover when animation frame is running
        let Mouse_style= "rgba(255,255,102,0.5)";
        if(!render_animation){
          let koete=nani_button_ga_koete(mouse_x,mouse_y,m_radius);

          //render the mouse to hover over
            if(koete!=-1){
              document.documentElement.style.cursor = "pointer";
              Mouse_style = "rgba(102,102,255,0.5)";
            }else{ 
              document.documentElement.style.cursor = "default";
              Mouse_style = "rgba(255,255,102,0.5)";
            }

          // do not highlight the engine button
          if(clicked_index>0){
            highlightButton(clicked_index);
          }
        }else{

          //wait one tick before rendering
          if(!actually_drawing){
            if(is_tick()){
              if(before_draw_ticks>1){
                actually_drawing=true;
                animation_itterator=0;
                start_message=false;
              }
              before_draw_ticks++;
            }
          }else{
            highlightButton_midori(random_sequence[animation_itterator]);
            if(is_tick()){
              
              animation_itterator++;
              if(animation_itterator >= random_sequence.length){
                render_animation=false;
                actually_drawing=false;
                animation_itterator=0;
                before_draw_ticks=0;
              }
            }
          }

          //gray
          document.documentElement.style.cursor = "default";
          Mouse_style = "rgba(66,66,66,0.5)";
        }


        if(final_message == 1){
          gazou.fillStyle = "rgba(0, 0, 0, 0.6)";
          gazou.fillRect(600, 350, 720, 100);
          gazou.fillStyle = "#FFFFFF";
          gazou.font = "50px Arial";
          gazou.textAlign = "center";
          var failSound = document.getElementById("failSound");
          failSound.currentTime = 0;
          failSound.play();
          gazou.fillText("Incorrect! Game over.", 960, 400); 
          resetGame();

        } else if (final_message == 2){
          gazou.fillStyle = "rgba(0, 0, 0, 0.6)";
          gazou.fillRect(600, 350, 720, 100);
          gazou.fillStyle = "#FFFFFF";
          gazou.font = "50px Arial";
          gazou.textAlign = "center";
          gazou.fillText("Congratulations! You completed the sequence.", 960, 400); 
        }
      
        gazou.strokeStyle = Mouse_style;
        drawCircle(gazou,mouse_x,mouse_y,m_radius);

        requestAnimationFrame(kurikaesu);
      }

      kurikaesu();

    </script>
  </body>
</html>
